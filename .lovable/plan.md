
## Что я вижу сейчас в коде (почему “не сработало”)

В `src/pages/ProductPage.tsx` уже стоит логика “защёлки”:

- `hasReachedReviews = useInView(reviewsAnchorRef, { ..., once: true })`
- hero-картинка должна уходить в `opacity: 0`, а sticky выключаться после отзывов.

Но якорь отзывов сейчас — это:

```tsx
<div ref={reviewsAnchorRef} className="h-px" />
```

То есть “цель” для `useInView` — элемент высотой 1px внутри контейнера, который на мобильном ещё и визуально двигается `transform: translateY(...)` (через `motion.div style={{ y: contentLiftY }}`).

Практически это даёт два класса проблем, из‑за которых триггер может не наступать стабильно (особенно на мобильных браузерах):

1) **Слишком маленький sentinel (1px)**: IntersectionObserver / frеймеровский `useInView` может “не поймать” пересечение так, как мы ожидаем (в комбинации с `margin` и `amount`).
2) **Сдвиги через transform**: визуальное положение “отзывов на экране” и расчёты пересечения иногда расходятся, когда часть страницы двигается transform’ом.

Итог: вы реально доходите до отзывов глазами, но `hasReachedReviews` остаётся `false`, поэтому картинка hero остаётся видимой и “просвечивает” внизу.

## Цель правки

- Как только пользователь доходит до отзывов на мобильном — hero-фото растворяется и **больше никогда не возвращается** (как вы выбрали).
- Никаких спейсеров, никаких увеличений футера, никаких огромных зазоров.

## Решение: убрать зависимость от IntersectionObserver и сделать “защёлку” по скроллу (на 100% детерминированно)

Вместо `useInView` сделаем “однократное срабатывание” по факту достижения позиции отзывов в документе:

### 1) Заменяем `useInView` на state + scroll-trigger (latch)

- Добавим состояние:
  - `const [hasReachedReviews, setHasReachedReviews] = useState(false);`

- В `useEffect` повесим `scroll`-листенер (passive), который:
  - если `hasReachedReviews === true` → ничего не делает (защёлка)
  - иначе берёт `reviewsAnchorRef.current`
  - вычисляет `triggerY` (когда считать “мы дошли до отзывов”):
    - `const triggerY = anchor.offsetTop - window.innerHeight * 0.35;`
  - если `window.scrollY >= triggerY` → `setHasReachedReviews(true)`

Почему это надёжнее:
- Не зависит от IntersectionObserver и размеров элемента.
- Не ломается из‑за “1px” якоря.
- Работает одинаково везде: iOS Safari / Chrome / Android.

### 2) Делаем так, чтобы даже если где-то появится “окошко прозрачности”, там не будет видно фото

Даже при корректной “защёлке” важно, чтобы внизу страницы не просвечивало ничего “фотографического”.

Сделаем два уровня защиты:

**(А) Плавно скрываем картинку**
- Оставляем fade/blur/scale (как у вас задумано), но управляем строго от `hasReachedReviews` из state.

**(Б) После скрытия делаем фон hero таким же, как фон страницы**
- Сейчас hero-контейнер имеет `bg-secondary`, и если где-то просветится фон — может быть заметно.
- Сделаем условие:
  - до отзывов: `bg-secondary` (как сейчас)
  - после отзывов: `bg-background` (чтобы даже при “просвете” это выглядело как обычный белый фон, а не как “подложка” подвалом)

### 3) Отключаем интерактивность hero после “защёлки” окончательно

- Уже есть `pointer-events-none` и условный `onClick`.
- Сохраняем это, чтобы не было “невидимых кликов” по hero внизу.

## Файлы, которые будут изменены

- `src/pages/ProductPage.tsx`
  1) удалить `useInView(...)` для отзывов
  2) добавить `useState + useEffect` с scroll-trigger latch
  3) привязать `isHeroSticky` и fade-анимацию к новому `hasReachedReviews`
  4) условно переключать фон hero-контейнера на `bg-background` после достижения отзывов

## Тест-план (как проверим, что это наконец исправлено)

На мобильном (или в узком окне браузера):

1) Открыть товар: hero видно, sticky работает.
2) Доскроллить до отзывов:
   - hero плавно растворяется (opacity → 0 + blur).
3) Доскроллить до самого низа/футера:
   - **фото hero нигде не видно** (ни при каком “доскролле”).
   - нет гигантских пустых зазоров перед футером.
4) Прокрутить вверх/вниз:
   - hero не возвращается вообще (поведение “навсегда”).

## Почему это должно сработать, даже если раньше не работало

Текущая проблема почти наверняка в том, что `useInView` не срабатывает в вашей реальной прокрутке из-за сочетания:
- 1px sentinel,
- rootMargin/threshold,
- transform-движения контента.

Scroll-trigger latch не использует эти механизмы вообще, поэтому устранит сам источник нестабильности.

## Бонус: минимальная диагностика (если вдруг вы снова увидите фото)

Если после внедрения scroll-trigger вы всё равно увидите hero:
- добавим временный `console.log` (только на мобиле) при переходе `hasReachedReviews` в `true`, чтобы подтвердить, что защёлка реально срабатывает.
- но в первую итерацию я постараюсь обойтись без логов, чтобы не засорять консоль.


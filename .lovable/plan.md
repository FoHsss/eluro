
Цель: полностью убрать ситуацию, когда hero-фото “возвращается” и снова видно в самом низу страницы на мобиле, при этом без любых спейсеров/зазоров перед футером. По вашему требованию: как только пользователь доскроллил до отзывов — hero должен плавно исчезнуть и больше не появляться (даже если дальше пролистывать вниз/вверх).

---

## Почему сейчас “ничего не меняется” (корень проблемы)

Сейчас логика завязана на `reviewsInView` (IntersectionObserver):

- `reviewsInView === true` только пока якорь отзывов находится в зоне видимости.
- Когда вы пролистываете ниже отзывов к самому низу страницы, якорь отзывов снова выходит из зоны видимости ⇒ `reviewsInView` становится `false`.
- Из‑за этого:
  - `isHeroSticky = isMobile && !reviewsInView` снова становится `true` (герой опять sticky),
  - анимация картинки снова делает `opacity: 1`,
  - поэтому hero “воскресает” и видно его внизу.

То есть проблема не в “фоне” и не в футере — проблема в том, что триггер “в зоне видимости” по природе своей временный, а вам нужен “один раз пересёк → навсегда выключился”.

---

## Правильное решение (без спейсеров): “защёлка” (latch) на момент достижения отзывов

Сделаем состояние, которое срабатывает один раз и больше не откатывается:

- пока пользователь не дошёл до отзывов: hero sticky и виден
- как только дошёл до отзывов: запускаем fade-out и **навсегда** фиксируем “hero выключен”
- после этого hero больше никогда не станет sticky и не вернёт opacity обратно

Есть два эквивалентных способа, выберу более простой и надёжный под ваше требование “навсегда”:

### Вариант A (самый простой): `useInView(..., { once: true })`

1) Переименуем `reviewsInView` в `hasReachedReviews` (по смыслу).
2) Добавим `once: true` в `useInView`, чтобы после первого попадания в зону видимости значение больше не возвращалось в `false`.

Дальше:
- `isHeroSticky = isMobile && !hasReachedReviews`
- opacity у hero-изображения: `hasReachedReviews ? 0 : 1`

Это гарантирует, что в самом низу страницы hero не “вернётся”, потому что `hasReachedReviews` уже навсегда `true`.

### Вариант B (ещё более контролируемый): state + effect-«защёлка»
Если вдруг окажется, что `once: true` ведёт себя нестабильно в конкретном браузере, сделаем:
- `const [hasReachedReviews, setHasReachedReviews] = useState(false)`
- `useEffect(() => { if (reviewsInView) setHasReachedReviews(true) }, [reviewsInView])`

Функционально для вас будет так же “навсегда”.

---

## Анимация “растворения” (чтобы выглядело аккуратно)

Чтобы это было именно “растворяется”, а не “пропало”, применим к `motion.img`:

- `animate.opacity` → 0
- `transition.duration` ~ 0.45–0.6s
- опционально небольшой blur/scale, чтобы выглядело как мягкое растворение:
  - `filter: blur(6px)` при исчезновении
  - `scale: 0.98` при исчезновении

Важно: при `hasReachedReviews === true` отключим кликабельность изображения, чтобы не было “невидимой кнопки”:
- `className` добавим `pointer-events-none` когда скрыто
- либо условно не навешивать `onClick`, если скрыто

---

## Что конкретно поменяем в коде

Файл: `src/pages/ProductPage.tsx`

1) Изменить `useInView`:
- было: `const reviewsInView = useInView(... { margin, amount })`
- станет: `const hasReachedReviews = useInView(... { margin, amount, once: true })`

2) Пересчитать sticky:
- было: `const isHeroSticky = isMobile && !reviewsInView;`
- станет: `const isHeroSticky = isMobile && !hasReachedReviews;`

3) Изменить fade condition на `hasReachedReviews`:
- было: `opacity: isMobile && reviewsInView ? 0 : 1`
- станет: `opacity: isMobile && hasReachedReviews ? 0 : 1`

4) (Опционально, но рекомендую) добавить “растворение”:
- при `hasReachedReviews` добавить blur/scale
- и `pointer-events-none` при скрытии

---

## Критерии готовности (как вы проверите, что это наконец исправлено)

На мобильном:
1) Открыть страницу товара, hero видно и оно sticky сверху.
2) Доскроллить до секции отзывов:
   - hero плавно растворяется.
3) Продолжить скролл до самого низа:
   - hero больше нигде не появляется,
   - нет искусственных зазоров перед футером,
   - футер сразу идёт после последнего блока контента.

Дополнительно (по вашему выбору поведения “навсегда”):
4) Прокрутить обратно вверх:
   - hero не возвращается (как вы выбрали).

---

## Риски / почему это надёжно

- Мы убираем фундаментальную проблему “inView туда-сюда” и заменяем на “один раз достигли → фиксируем состояние”.
- Это не требует спейсеров, не трогает футер, не ломает верстку.
- Это не зависит от высоты страницы и количества блоков ниже отзывов.

---